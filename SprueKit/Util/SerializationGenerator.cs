using System;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Collections.Generic;

using IntVector2 = PluginLib.IntVector2;
using IntVector4 = PluginLib.IntVector4;
using Color = Microsoft.Xna.Framework.Color;
using Vector2 = Microsoft.Xna.Framework.Vector2;
using Vector3 = Microsoft.Xna.Framework.Vector3;
using Vector4 = Microsoft.Xna.Framework.Vector4;
using Mat3x3 = PluginLib.Mat3x3;
using Matrix = Microsoft.Xna.Framework.Matrix;
using Quaternion = Microsoft.Xna.Framework.Quaternion;
using System.IO;
using System.Xml.Serialization;

namespace SprueKit.Util
{
    /// <summary>
    /// Generates all of the serialization code for graph nodes
    /// </summary>
    public class SerializationGenerator
    {
        /// <summary>
        /// Main method, use this to dump serialization autogenerated code into a StringBuilder for a list of types
        /// </summary>
        public static void ProcessTypes(StringBuilder output, Type[] types)
        {
            foreach (var type in types)
                ProcessType(output, type);
        }

        static void WritePropertyMethod(StringBuilder output, Type owningType, PropertyInfo propertyInfo, bool isWrite, bool isBinary)
        {
            string indent = "            ";
            if (propertyInfo.PropertyType == typeof(bool))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadBoolean();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetBoolElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(int))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadInt32();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetIntElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(uint))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadUInt32();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetUIntElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(float))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadSingle();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetFloatElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(double))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadDouble();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = (double)thisElem.GetFloatElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Color))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToColor();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Vector2))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToVector2();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Vector3))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToVector3();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Vector4))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToVector4();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Quaternion))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToQuaternion();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(IntVector2))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToIntVector2();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(IntVector4))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToIntVector4();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Mat3x3))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToMat3x3();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(Matrix))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\").ToMatrix();", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType == typeof(string))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write({1} ?? \"\");", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = strm.ReadString();", indent, propertyInfo.Name, owningType.Name));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = thisElem.GetStringElement(\"{1}\");", indent, propertyInfo.Name));
                }
            }
            else if (propertyInfo.PropertyType.IsEnum)
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}strm.Write((int){1});", indent, propertyInfo.Name));
                    else
                        output.AppendLine(string.Format("{0}{1} = ({2})strm.ReadInt32();", indent, propertyInfo.Name, propertyInfo.PropertyType.FullName.Replace("+", ".")));
                }
                else
                {
                    if (isWrite)
                        output.AppendLine(string.Format("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name));
                    else
                    {
                        string enumName = propertyInfo.PropertyType.FullName.Replace("+", ".");
                        output.AppendLine(string.Format("{0}{1} = ({2})Enum.Parse(typeof({2}), thisElem.GetStringElement(\"{1}\"));", indent, propertyInfo.Name, enumName));
                    }
                }
            }
            else if (propertyInfo.PropertyType == typeof(Uri))
            {
                var resourceTag = propertyInfo.GetCustomAttribute<PropertyData.ResourceTagAttribute>();
                if (resourceTag == null)
                    throw new Exception(string.Format("FAILED TO FIND RESOURCE TAG ON URI: {0}.{1}", propertyInfo.DeclaringType.Name, propertyInfo.Name));

                string maskString = "FileData.SprueModelMask";
                switch (resourceTag.Type)
                {
                    case PropertyData.ResourceTagType.ForeignModel:
                        maskString = "FileData.ModelFileMask";
                        break;
                    case PropertyData.ResourceTagType.RasterTexture:
                        maskString = "FileData.ImageFileMask";
                        break;
                    case PropertyData.ResourceTagType.SVGTexture:
                        maskString = "FileData.SVGFileMask";
                        break;
                }
                if (isBinary)
                {
                    if (isWrite)
                    {
                        output.AppendLine(string.Format("{0}if ({1} != null && System.IO.File.Exists({1}.AbsolutePath)) {{", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    strm.Write(true);", indent));
                        output.AppendLine(string.Format("{0}    strm.Write(ctx.GetRelativePathString({1}));", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}} else strm.Write(false);", indent));
                    }
                    else
                    {
                        output.AppendLine(string.Format("{0}if (strm.ReadBoolean()) {{", indent));
                        output.AppendLine(string.Format("{0}    Uri result = ctx.GetAbsolutePath(new Uri(strm.ReadString()), this, \"{2}\", \"{2}\", {3});", indent, propertyInfo.Name, owningType.Name, maskString));
                        output.AppendLine(string.Format("{0}    if (result != null) {1} = result;", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}}", indent));
                    }
                }
                else
                {
                    if (isWrite)
                    {
                        output.AppendLine(string.Format("{0}if ({1} != null && System.IO.File.Exists({1}.AbsolutePath))", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    thisElem.AddStringElement(\"{1}\", ctx.GetRelativePathString({1}));", indent, propertyInfo.Name));
                    }
                    else
                    {
                        output.AppendLine(string.Format("{0}{{", indent));
                        output.AppendLine(string.Format("{0}    string fileString = thisElem.GetStringElement(\"{1}\");", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    if (!string.IsNullOrWhiteSpace(fileString)) {{", indent));
                        output.AppendLine(string.Format("{0}        Uri result = ctx.GetAbsolutePath(new Uri(thisElem.GetStringElement(fileString)), this, \"{2}\", \"{2}\", {3});", indent, propertyInfo.Name, owningType.Name, maskString));
                        output.AppendLine(string.Format("{0}        if (result != null) {1} = result;", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    }}", indent));
                        output.AppendLine(string.Format("{0}}}", indent));
                    }
                }
            }
            else if (propertyInfo.PropertyType == typeof(Data.ForeignModel))
            {
                if (isBinary)
                {
                    if (isWrite)
                    {
                        output.AppendLine(string.Format("{0}if ({1} != null && {1}.ModelFile != null) {{", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    strm.Write(true);", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    {1}.Write(ctx, strm);", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}} else strm.Write(false);", indent));
                    }
                    else
                    {
                        output.AppendLine(string.Format("{0}if (strm.ReadBoolean()) {{", indent));
                        output.AppendLine(string.Format("{0}    {1}.Read(ctx, strm);", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}}", indent));
                    }
                }
                else
                {
                    if (isWrite)
                    {
                        output.AppendLine(string.Format("{0}if ({1} != null && {1}.ModelFile != null) {{", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    var mdl = thisElem.CreateChild(\"{1}\");", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    {1}.Write(ctx, mdl);", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}}", indent));
                    }
                    else
                    {
                        output.AppendLine(string.Format("{0}{{ var mdlElem = thisElem.SelectSingleNode(\"{1}\") as XmlElement;", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}    if (mdlElem != null) {1}.Read(ctx, mdlElem);", indent, propertyInfo.Name));
                        output.AppendLine(string.Format("{0}}}", indent));
                    }
                }
            }
            else if (propertyInfo.PropertyType == typeof(Data.ResponseCurve))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendFormat("{0}strm.Write({1});", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name);
                }
                else
                {
                    if (isWrite)
                        output.AppendFormat("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = thisElem.GetStringElement(\"{1}\").ToResponseCurve();", indent, propertyInfo.Name);
                }
            }
            else if (propertyInfo.PropertyType == typeof(Data.ColorCurves))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendFormat("{0}strm.Write({1});", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name);
                }
                else
                {
                    if (isWrite)
                        output.AppendFormat("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = thisElem.GetStringElement(\"{1}\").ToColorCurves();", indent, propertyInfo.Name);
                }
            }
            else if (propertyInfo.PropertyType == typeof(Data.ColorRamp))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendFormat("{0}strm.Write({1});", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = strm.Read{2}();", indent, propertyInfo.Name, propertyInfo.PropertyType.Name);
                }
                else
                {
                    if (isWrite)
                        output.AppendFormat("{0}thisElem.AddStringElement(\"{1}\", {1}.ToTightString());", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = thisElem.GetStringElement(\"{1}\").ToColorRamp();", indent, propertyInfo.Name);
                }
            }
            else if (propertyInfo.PropertyType == typeof(Data.TextureMap))
            {
                throw new Exception("TextureMap was not expected to be serialized");
            }
            else if (propertyInfo.PropertyType == typeof(Data.FontSpec))
            {
                if (isBinary)
                {
                    if (isWrite)
                        output.AppendFormat("{0}strm.Write({1});", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = strm.ReadFontSpec();", indent, propertyInfo.Name);
                }
                else
                {
                    if (isWrite)
                        output.AppendFormat("{0}thisElem.AddStringElement(\"{1}\", {1}.ToString());", indent, propertyInfo.Name);
                    else
                        output.AppendFormat("{0}{1} = Data.FontSpec.FromString(thisElem.GetStringElement(\"{1}\"));", indent, propertyInfo.Name);
                }
            }
        }

        public static void ProcessType(StringBuilder output, Type type)
        {
            output.AppendLine(string.Format("namespace {0} {{", type.Namespace));
            output.AppendLine(string.Format("    public partial class {0} {{", type.Name));
            output.AppendLine("        public override void SerializeProperties(SerializationContext ctx, XmlElement thisElem) {");
            var properties = type.GetProperties();
            foreach (var propertyInfo in properties)
            {
                if (propertyInfo.CanWrite && propertyInfo.GetCustomAttribute<XmlIgnoreAttribute>() == null)
                    WritePropertyMethod(output, type, propertyInfo, true, false);
            }

            if (typeof(Data.IPermutable).IsAssignableFrom(type))
                output.AppendLine("            PermutationSerialization.SerializePermutations(ctx, thisElem, this, Permutations);");
            output.AppendLine("        }"); // end SerializeProperties

            output.AppendLine("        public override void DeserializeProperties(SerializationContext ctx, XmlElement thisElem) {");
            foreach (var propertyInfo in properties)
            {
                if (propertyInfo.CanWrite && propertyInfo.GetCustomAttribute<XmlIgnoreAttribute>() == null)
                    WritePropertyMethod(output, type, propertyInfo, false, false);
            }
            if (typeof(Data.IPermutable).IsAssignableFrom(type))
                output.AppendLine("            PermutationSerialization.DeserializePermutations(ctx, thisElem, this, Permutations);");
            output.AppendLine("        }"); // end DeserializeProperties

        // Binary serialization
            output.AppendLine("        public override void SerializeProperties(SerializationContext ctx, BinaryWriter strm) {");
            foreach (var propertyInfo in properties)
            {
                if (propertyInfo.CanWrite && propertyInfo.GetCustomAttribute<XmlIgnoreAttribute>() == null)
                    WritePropertyMethod(output, type, propertyInfo, true, true);
            }
            if (typeof(Data.IPermutable).IsAssignableFrom(type))
                output.AppendLine("            PermutationSerialization.SerializePermutations(ctx, strm, this, Permutations);");
            output.AppendLine("        }"); // end SerializeProperties

            output.AppendLine("        public override void DeserializeProperties(SerializationContext ctx, BinaryReader strm) {");
            foreach (var propertyInfo in properties)
            {
                if (propertyInfo.CanWrite && propertyInfo.GetCustomAttribute<XmlIgnoreAttribute>() == null)
                    WritePropertyMethod(output, type, propertyInfo, false, true);
            }
            if (typeof(Data.IPermutable).IsAssignableFrom(type))
                output.AppendLine("            PermutationSerialization.DeserializePermutations(ctx, strm, this, Permutations);");
            output.AppendLine("        }"); // end DeserializeProperties

        // Clone method

            output.AppendLine("        public override Data.Graph.GraphNode Clone() {");
            output.AppendLine(string.Format("            {0} retVal = new {0}();", type.Name));
                          output.AppendLine("            CloneFields(retVal);");
                          output.AppendLine("            return retVal;");
                          output.AppendLine("        }"); // end Clone()

            output.AppendLine("        protected override void CloneFields(Data.Graph.GraphNode into) {");
            output.AppendLine("            base.CloneFields(into);");
            output.AppendLine(string.Format("            {0} retVal = into as {0};", type.Name));
            var fields = type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
            foreach (var fieldInfo in fields)
            {
                // don't clone non-serialized fields
                if (fieldInfo.GetCustomAttribute<NonSerializedAttribute>() != null)
                    continue;

                //WARNING: explicit hacks
                if (fieldInfo.FieldType == typeof(Data.ColorRamp) || fieldInfo.FieldType == typeof(Data.ColorCurves) || fieldInfo.FieldType == typeof(Data.ResponseCurve) || fieldInfo.FieldType == typeof(Data.FontSpec) || fieldInfo.FieldType == typeof(FastNoise))
                    output.AppendLine(string.Format("            retVal.{0} = this.{0}.Clone();", fieldInfo.Name));
                else if (!fieldInfo.IsSpecialName && !fieldInfo.Name.StartsWith("<"))
                    output.AppendLine(string.Format("            retVal.{0} = this.{0};", fieldInfo.Name));
            }
            //WARNING: more field cloning hacks and short circuits
            if (typeof(Data.TexGen.CachingNode).IsAssignableFrom(type))
                output.AppendLine("            retVal.cacheScale_ = this.cacheScale_;");

            output.AppendLine("        }"); // end CloneFields
            output.AppendLine("    }"); // end class
            output.AppendLine("}"); // end namespace
        }

    }

    public class VersionProperty
    {
        public string PropertyName { get; set; }
        public string PropertyType { get; set; }
    }

    public class ObjectVersion
    {
        public string TypeName { get; set; }
        public int Version { get; set; }
        public List<VersionProperty> Properties { get; set; }

        public ObjectVersion(Type forType)
        {
            TypeName = forType.Name;
            var foundVersion = forType.GetField("Version", BindingFlags.Public | BindingFlags.Static);
            if (foundVersion != null)
                Version = (int)foundVersion.GetValue(null);
            else
                Version = 1;
        }

        public void Write(XmlElement into)
        {
            var self = into.CreateChild("versioned");
            self.AddStringElement("typename", TypeName);
            self.AddStringElement("version", Version.ToString());
            foreach (var prop in Properties)
            {
                var propElem = self.CreateChild("property");
                propElem.AddStringElement("name", prop.PropertyName);
                propElem.AddStringElement("typename", prop.PropertyType);
            }
        }

        public static List<ObjectVersion> Load(XmlElement root)
        {
            List<ObjectVersion> ret = new List<ObjectVersion>();
            var objects = root.SelectNodes("/versioned");

            foreach(var obj in objects)
            {
                var elem = obj as XmlElement;
                ret.Add(new Util.ObjectVersion(elem));
            }

            return ret;
        }

        public ObjectVersion(XmlElement fromElem)
        {
            TypeName = fromElem.GetStringElement("typename");
            Version = int.Parse(fromElem.GetStringElement("version"));
            var props = fromElem.SelectNodes("/property");
            if (props != null && props.Count > 0)
            {
                foreach (var prop in props)
                {
                    var elem = prop as XmlElement;
                    var propData = new VersionProperty
                    {
                        PropertyName = elem.GetStringElement("name"),
                        PropertyType = elem.GetStringElement("typename")
                    };
                    Properties.Add(propData);
                }
            }
        }
    }
}
